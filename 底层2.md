---
typora-copy-images-to: ipic
---

[TOC]

## runloop

> 一个线程只有一个runloop 主线程默认开启 ，子线程刚创建时并没有`RunLoop`子线程默认没有开启

- 子线程开启任务一般只能跑一次 就被销毁 需要开启线程保活来不停运行任务 自己设置销毁时机

```c
struct __CFRunLoop {            
    pthread_t _pthread;
    CFMutableSetRef _commonModes; //标记为common的mode的集合
    CFMutableSetRef _commonModeItems;  //commonMode的item集合
    CFRunLoopModeRef _currentMode;// 当前的模式
    CFMutableSetRef _modes;// CFRunLoopModeRef类型的集合，相对NSArray有序，Set为无序集合
};

typedef struct __CFRunLoopMode *CFRunLoopModeRef;
struct __CFRunLoopMode {
    CFMutableSetRef _sources0;
    CFMutableSetRef _sources1;
    CFMutableArrayRef _observers;
    CFMutableArrayRef _timers;
}
```

### Mode

> 每个runloop有多个mode  多个`mode`里，有且仅有一个为`currentMode`

![WeChata76d35e93d3e44025489eae76f129709](https://tva1.sinaimg.cn/large/e6c9d24egy1h4b8l1uxkmj20rs0ocdi7.jpg)

- 如果要切换`Mode`，只能退出当前 Loop，再重新指定一个`Mode` 进入。这样做主要是为了分隔开不同组的 `Source/Timer/Observer`，让其互不影响

####  事件源

> 触发事件的方式

- input source

  ```objective-c
    // 一个联合体，说明 source 要么为 source0，要么为 source1
      union {
          CFRunLoopSourceContext version0;  /* immutable, except invalidation */
          CFRunLoopSourceContext1 version1; /* immutable, except invalidation */
      } 
  ```

  - source0 不能唤醒runloop 调用source0时内部可能是通知mach port来唤醒runloop

    - 触摸事件处理


    - 手动触发 custom事件 hitTest:withEvent
    - performSelector事件 
    
    ​```objective-c
    //点击屏幕 bt 函数调用栈信息
    - (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event {
        NSLog(@"点击屏幕");
    }
    frame #8: 0x0000000180360820 CoreFoundation`__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 24
    frame #9: 0x0000000180360720 CoreFoundation`__CFRunLoopDoSource0 + 204
    ​```
    
    ​```objective-c
    //下面这个方法同样产生source0
    [self performSelector:@selector(performEvent) onThread:self.innerThread withObject:nil waitUntilDone:YES];
    - (void)performEvent {
        NSLog(@"处理Perform事件");
    }
    ​```

  - source1  **包含了一个 mach_port 和一个回调（函数指针）**Runloop的睡眠和唤醒

    - 基于mach_Port的, 系统内核或者其他进程或线程的事件 可以主动唤醒休眠中的RunLoop

    - mach_port大家就理解成进程间相互发送消息的一种机制就好,对应**port的事件源**

    - 简单举个例子：一个APP在前台静止着，此时，手指点击屏幕，首先产生的是一个系统事件，通过source1来接受捕捉,source1唤醒RunLoop, 然后将事件Event由**Springboard**程序包装成`source0`

      分发给app处理

      ![08A3DA44-AECD-4A18-AA59-F995D4280760](https://tva1.sinaimg.cn/large/e6c9d24egy1h4d6qprbhpj20xg0gsgmg.jpg)

    ![3A8D0CFC-DF04-4890-8F0A-81B7BEDE4A3C](https://tva1.sinaimg.cn/large/e6c9d24egy1h4d6csd37rj21f20gc0tx.jpg)

- timer source

  - **CFRunLoopTimerRef**  
  - 定时器事件 
  - [performSelector: withObject: afterDelay:]

#### observer

- Runloop的状态切换时，都会被`observer`监听到
- ​

### 休眠的实现

> 用户状态切换到内核态 当前线程不干事情 等待source1唤醒

- mach_msg()内核


### 线程保活

> 主线程不要关闭子线程的runloop

- waitUntilDone设置为`NO` 表示子线程执行任务时不用等待 其他主线程也可以同时进行  YES表示必须等待执行完成



## 多线程

### GCD

- sync  当前线程 也就是在主线程执行 不能并发 不能开新线程
- async  子线程  异步能开新线程

#### 死锁

- 队列FIFO 原则
- **使用sync函数往当前串行队列添加任务会死锁** 串行必须一步一步往下执行

```objective-c
//主线程互相等待死锁
- (void)viewDidLoad {
    [super viewDidLoad];
    NSLog(@"0");
    // 等
    dispatch_sync(dispatch_get_main_queue(), ^{
        NSLog(@"1");
    });
    NSLog(@"2");
//   dispatch_sync(dispatch_get_main_queue(), ^任务块需要 1完成打印才能返回  打印1又在任务块的后面 同步又是按顺序来执行 所以相互等待
}
```

![C4B7E751-3007-4283-BF9E-64156104F983](https://tva1.sinaimg.cn/large/e6c9d24egy1h4dc9qi7zaj21rk0ho40b.jpg)

#### 异步

```objective-c
//异步并发队列中 只打印13  afterDelay是NStimer 在runloop中 异步生成子线程 runloop默认没有开启
-(void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{
    dispatch_queue_t queue2 = dispatch_queue_create("myqueu2", DISPATCH_QUEUE_CONCURRENT);
    dispatch_async(queue2, ^{
        NSLog(@"1");
        [self performSelector:@selector(test2) withObject:nil afterDelay:.0];
        NSLog(@"3");
    });
}
-(void)test2{
    NSLog(@"2");
}
```

### group

### 优缺点

- 多个线程访问同一个资源 ，会引发数据错乱和数据安全

```objective-c
- (void)ticketTest{
    self.ticketsCount = 10;
    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
    dispatch_async(queue, ^{
        for (int i = 0; i < 5; i++) {
            [self saleTicket];
        }
    });
    dispatch_async(queue, ^{
        for (int i = 0; i < 5; i++) {
            [self saleTicket];
        }
    });
}
- (void)saleTicket{
    int oldTicketsCount = self.ticketsCount;
    oldTicketsCount--;
    self.ticketsCount = oldTicketsCount;
    NSLog(@"还剩%d张票 - %@", oldTicketsCount, [NSThread currentThread]);
}

```



- 解决方案：使用线程同步技术

### 线程同步 Lock

> 防止多个线程访问同一个变量  同一时间只能做一件事情 同时读取不用加锁 同时改需要

- 互斥锁和自旋锁
  - 假设有一个线程加锁成功，其他线程加锁自然会失败，失败线程的处理方式如下
    - **互斥锁**加锁失败后，线程释放CPU，给其他线程
    - **自旋锁**加锁失败后，线程会忙等待，直到它拿到锁
  - 自旋锁使用  cpu一直占用资源
    - 其他线程等待时间比较短
    - 多核处理器


- osspinlock  自旋锁  利用cpu周期 一直自旋 直到锁可用

  ```objective-c
  //1.先执行task2，拿到spin_lock，由于任务比较耗时，未执行完，继续持有锁。 2.紧接着执行task1，等待锁释放。由于优先级高， task1线程也尝试获得这个锁，它会处于spin lock 的忙等状态，占用大量CPU, 此时low priority线程无法与high priority线程争夺CPU时间，从而导致任务无法正常完成，以及释放锁
  task1：high priority，要使用资源data
  task2：low priority，要使用资源data
  spin_lock：一把自旋锁
  ```

  ​

- os_unfair_lock **推荐**

- pthread_mutex 递归锁 ，互斥锁 等待锁的线程会处于休眠状态

  - 允许同一个线程对一把锁进行重复加锁

- dispatch_semaphore **推荐**

- NSLock 互斥锁

- DISPATCH_QUEUE_SERIAL 串行队列保证线程同步

- dispatch_semaphore_t

  - 初始值 控制线程并发访问的最大值

  ```objective-c
  // 根据信号量的值，判断是休眠还是继续执行代码 设置初始值之后 >0 后面每次进来就-1 直到=0 就开始休眠
      dispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER);
  // 信号量的值加一
      dispatch_semaphore_signal(self.semaphore);

  ```

  ​


### 读写安全

- atomic 原子性 不可分割

  ```objective-c
   // Atomic retain release world
      spinlock_t& slotlock = PropertyLocks[slot];
      slotlock.lock();
      id value = objc_retain(*slot);
      slotlock.unlock();
  @property(atomic,strong)NSMutableArray *arr;
  self.arr = [NSMutableArray array];//这句操作set方法 加锁了 线程安全
  [self.arr addObject:@"1"];//这句不是线程安全 addObject和set方法没关系了
  ```

  - 保证属性的setter和getter内部线程同步 原子性操作

- nonatomic

- **多读单写**同一时间 只能一个线程写  允许多个线程读 不能既有写的操作 又有读的操作 

  - pthread rwlock
  - dispatch_barrier_(a)sync 解决数据竞争问题 同步函数无需栅栏函数
    - 栅栏函数仅与并发队列（DISPATCH_QUEUE_CONCURRENT）有效
    - 异步栅栏挡住后面的任务执行 必须自己里面的执行完 但是可以和前面的任务并行

## 内存管理

### 循环引用

- NSTime

  ```objective-c
  //timer内部target强引用 不能释放
  self.timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(timerTest) userInfo:nil repeats:YES];
  //解决方案1
  __weak typeof(self)weakSelf = self;
      self.timer = [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) {
          [weakSelf timerTest];
      }];
  //利用中间对象去解决 NSProxy消息转发实现target方法
  ```

- NSProxy 转发消息的场所 实现了NSObject协议，类似于 NSObject 的根类

  - 必须要实现它的 forwardInvocation: 和 methodSignatureForSelector: 方法

  - NSObject 寻找方法顺序：本类 -> 父类 -> 动态方法解析 -> 备用对象 -> 消息转发；

     NSproxy 寻找方法顺序：本类-> 消息转发；

### GCD定时器



