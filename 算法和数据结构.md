---
typora-copy-images-to: ipic
---

[TOC]

### 任务列表 

- [x] eat

- [x] heat


 - [x] [check this url](https://www.baidu.com)
 - [ ] run

## 引用

> quote
>
> > quote
> >
> > > quote
> > >
> > > 

## 标注

Test1[^1]

[^1]: 解释test1

Demo[^2]

[^2]: demo2

`print("hello")`

## 上标和下标

h~2~o

x^2^

h~2~o

x^2^



## 公式

$$sum_{i=1}^n a_i=0$$



$$sum$$

## 内存对齐

- .收尾工作:结构体的总大小，也就是sizeof的结果，**必须是其内部最大成员的整数倍**，不足的要补齐

1. ``` c
    struct DRStruct1 {    
    double a;    char   b;    int c;    char d; 
    }MyStruct;
       分析：- a占8个字节 
     -b占用一个字节 根据内存对齐规则 起始位置（第八个位置）为所占空间的整数倍（b所占空间为1，所以b不需要调整 ，
     - c占4个字节 但是c的起始位置是9，根据对齐规则起始位置应该为4的倍数 只能是4*2 4*3，所以从第12个位置开始 
     - d 1个字节 且位置16 符合规则  
     
    ```
   ```

   ![image.png](https://tva1.sinaimg.cn/large/e6c9d24egy1h32e8ind0mj20xc06z74p.jpg)

   2. ```c
      typedef struct DRStruct1 {
          char   b;
          double c;
          char d;
      }MyStruct;
      sizeof(MyStruct) = 24
      
      struct DRStruct2 {
          char d;
          char   b;
          MyStruct c;
      }MyStruct1;
      sizeof(MyStruct1) = 32
        
       分析 -d 起始位置为0，占用位置为0
      	- b占用1个字节，起始位置为1，占用位置为1
        - c MyStruct占用24字节，起始位置为2，根据对其规则，其中最大的为double类型8个字节，故后延查找8的整数倍为8，由此得出从起始位置为8，占用位置为（8-31），共占用31个字节，为8的整数倍，符合对齐规则，得出MyStruct1的sizeof为32.
   ```

   ![image.png](https://tva1.sinaimg.cn/large/e6c9d24egy1h32eqft5ycj20xc05k3z8.jpg)

## 对象的分类

- 生成main.cpp文件

  ```
  feellife@apps-iMac isa指针01 % xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m 

  ```

### instance

- 存储的信息包括
  - isa 指针 8个字节 作用 调用父类方法
  - 其他成员变量
  - isa的地址在对象的最前面 所以也就是对象的地址
- 不存储**实例对象方法**

### class对象

- class的superclass指针

  > 调用实例方法 

  - student 调用init方法时 init属于NSObject 先通过isa找到student的class对象 在通过superclass找到 person的class ==》person的superclass找到 NSObject的class

  ![74AC9D7A-7C45-4F9C-929F-90C8F632AD57](https://tva1.sinaimg.cn/large/e6c9d24egy1h3i4hg50aqj21sk0tegqz.jpg)


- 存储**实例对象方法**

![img](https://upload-images.jianshu.io/upload_images/6545546-81240313e9a503dc.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

- isa指针
- super_class指针

### meta-class

- **存储类对象**


- 元类是一个类对象的类  （也是一个对象，所以也必须有类指针）

- 使用super_class 指针来指向 superclass

- 调用类方法流程

  > 调用类方法时 通过isa找到student的meta-class 通过meta-class里面的superclass找到person的meta-class --》〉


### isa superclass

- **instance的isa指向class  class的isa指向meta-class meta-class的isa指向 root-class的meta-class**


- subclass 子类 Student  Superclass Person  rootclass NSObject 
  - Student继承自Person类

- [x] ​

------

![img](https://upload-images.jianshu.io/upload_images/3044508-18e0ce1fedc91a37.jpeg?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

- subclass查找实例方法流程

  ![1105A5B6-2F5E-4336-A376-C1D900042385](https://tva1.sinaimg.cn/large/e6c9d24egy1h3j5bppdpnj20oi10qae1.jpg)

- subclass查找类方法

  ![6E274132-9F0F-441D-B25B-6312FC2644C5](https://tva1.sinaimg.cn/large/e6c9d24egy1h3j64l749wj20v80u0aer.jpg)

### class和meta-class inside结构

```
struct objc_object {
    Class _Nonnull isa;
};

struct objc_class : objc_object {
    Class superclass;
    cache_t cache;
    class_data_bits_t bits;    // 用户获取类的具体信息
}
```



## KVO

```
[self.person addObserver:self forKeyPath:@"age" options:options context:nil]; 
//context 上下文传递
```

- 添加监听的属性 会使用runtime动态生成派生类-NSKVONotifying_person ，并且让instance的isa指向全新的类，是Person的子类 里面的superlcass指针指向Person  通过foundation底层方法改变值

- 没有监听属性的对像isa 打印依然是Person  object_getClassName 打印

  ```objective-c
  (lldb) p object_getClassName(self.person)
  (const char * _Nonnull) $0 = 0x0000600002063360 "NSKVONotifying_Person"
  //  person2是没有添加观察的类 isa指向的是class对象 按照之前的图
    (lldb) p object_getClassName(self.person2)
  (const char * _Nonnull) $1 = 0x00000001026572de "Person"
  ```

- 打印地址值

  ```objective-c
   NSLog(@"%p --%p",[self.person methodForSelector:@selector(setAge:)],[self.person2 methodForSelector:@selector(setAge:)]);
  (lldb) p (IMP) 0x100381d94
  (IMP) $0 = 0x0000000100381d94 (KVO`-[Person setAge:] at Person.h:13)
  (lldb) p (IMP) 0x1807ab9bc
  (IMP) $1 = 0x00000001807ab9bc (Foundation`_NSSetIntValueAndNotify)
  ```

### NSKVONotifying_person实现

![img](https://upload-images.jianshu.io/upload_images/3333296-36bcadffb5a684bd.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

- 调用Foundation _NSSetIntValueAndNotify方法 实现

  ```objective-c
  [self willChangeValueForKey:@"age"];调用自己的方法
  [super setAge:age]; 调用原类Person的set方法 修改属性值
  [self didChangeValueForKey:@"age"];再回来调用自己的方法
  ```

- Foundation封闭 可以通过重写父类方法也就是Person类添加 willchange 和didchange 方法验证 



### 应用场景

- 看instance是否有set方法

- 直接修改属性不会触发 

  ```
  通过暴露属性去修改不会触发
  {
    @public
    int _age;
  }
  ```

  ​

## KVC

-  person类里定义cat对象 修改cat成员的值

  ```
   //cat对象必须要存在
      [self.person setValue:@49 forKeyPath:@"cat.weight"];
  ```

- KVC会触发KVO监听 不管有没有set方法都会触发

  [取值表]()

  ![img](https://upload-images.jianshu.io/upload_images/4130989-3b4c3c7cc11c1b8c.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)



## Category



## 数据结构

### 链表

## 常用算法

### 时间复杂度

![img](https://tva1.sinaimg.cn/large/e6c9d24egy1h3b3tzai9tj21gl0u0gta.jpg)

### Binary Search（BS 二分查找）

- 前提 必须在有序数据中查找
- 方法：每次将范围[left right]分割成【left mid】[mid right]


- ![img](https://tva1.sinaimg.cn/large/e6c9d24egy1h38omdw8j5j217005wweq.jpg)

  ​

- ​

### 应用场景

- 看instance是否有set方法

- 直接修改属性不会触发 

  ```
  通过暴露属性去修改不会触发
  {
    @public
    int _age;
  }
  ```

  ​

## 数据结构

### 链表

## 常用算法

### 时间复杂度

![img](https://tva1.sinaimg.cn/large/e6c9d24egy1h3b3tzai9tj21gl0u0gta.jpg)

### Binary Search（BS 二分查找）

- 前提 必须在有序数据中查找
- 方法：每次将范围[left right]分割成【left mid】[mid right]


- ![img](https://tva1.sinaimg.cn/large/e6c9d24egy1h38omdw8j5j217005wweq.jpg)

  ​

- ​

### 应用场景

- 看instance是否有set方法

- 直接修改属性不会触发 

  ```
  通过暴露属性去修改不会触发
  {
    @public
    int _age;
  }
  ```

  ​

## 数据结构

### 链表



## 常用算法

### 时间复杂度

![WeChat2012736d701aae44d7379183a10dac19](https://tva1.sinaimg.cn/large/e6c9d24egy1h3b3tzai9tj21gl0u0gta.jpg)

### Binary Search（BS 二分查找）

- 前提 必须在有序数据中查找
- 方法：每次将范围[left right]分割成【left mid】[mid right]


- ![WeChat8c63672552e59cabce9630239281fa7c](https://tva1.sinaimg.cn/large/e6c9d24egy1h38omdw8j5j217005wweq.jpg)

  ​

- ​








