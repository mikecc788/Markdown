---
typora-copy-images-to: ipic
---

[TOC]

### 任务列表 

- [x] eat

- [x] heat


 - [x] [check this url](https://www.baidu.com)
 - [ ] run

## 标注

Test1[^1]

[^1]: 解释test1

Demo[^2]

[^2]: demo2

`print("hello")`

## 上标和下标

h~2~o

x^2^

h~2~o

x^2^



## 公式

$$sum_{i=1}^n a_i=0$$



$$sum$$

## 内存管理

- void*指针 64位占8个字节 isa也是 函数指针也是8字节

### 栈区(Stack) FILO

- 地址空间在iOS中`通常以0x7开头`
- 栈区一般是`由编译器来自动分配和释放的`，主要用来存储
  - `局部变量`
  - `函数的参数`，例如函数的隐藏参数（id self，SEL_cmd）
- 栈的内存较小（iOS主线程栈大小1MB，其它线程512KB）
- 存储数据不灵活（存储内容基本固定，由编译器分配）

### 堆区 (Heap) FIFO

- 堆的地址空间在iOS中`通常以0x6开头`
- 堆区一般是`由开发者自己分配和释放的`，同时系统也会在必要的时候对堆区存储的内容进行回收和释放（`系统检测属性或者对象引用计数为零时，进行回收`）
  - OC使用alloc、new、block或者使用copy创建的对象都会存在这里
- 访问堆区内存时，一般是先通过对象读取到对象所在的栈区的指针地址，然后通过指针地址访问堆区

### 全局区

- 在iOS一般是`以0x1开头` 在程序`运行的过程中该数据就一直存在`，程序`结束后再由系统释放`
- 未初始的全局变量
- 未初始化静态变量

### 常量区

- `初始化过得全局变量`
- `初始化过得静态变量`

### 代码区

## 内存对齐

- .收尾工作:结构体的总大小，也就是sizeof的结果，**必须是其内部最大成员的整数倍**，不足的要补齐

1. ``` c
    struct DRStruct1 {    
    double a;    char   b;    int c;    char d; 
    }MyStruct;
       分析：- a占8个字节 
     -b占用一个字节 根据内存对齐规则 起始位置（第八个位置）为所占空间的整数倍（b所占空间为1，所以b不需要调整 ，
     - c占4个字节 但是c的起始位置是9，根据对齐规则起始位置应该为4的倍数 只能是4*2 4*3，所以从第12个位置开始 
     - d 1个字节 且位置16 符合规则  
     
    ```
   ```

   ![image.png](https://tva1.sinaimg.cn/large/e6c9d24egy1h32e8ind0mj20xc06z74p.jpg)

   2. ```c
      typedef struct DRStruct1 {
          char   b;
          double c;
          char d;
      }MyStruct;
      sizeof(MyStruct) = 24
      
      struct DRStruct2 {
          char d;
          char   b;
          MyStruct c;
      }MyStruct1;
      sizeof(MyStruct1) = 32
        
       分析 -d 起始位置为0，占用位置为0
      	- b占用1个字节，起始位置为1，占用位置为1
        - c MyStruct占用24字节，起始位置为2，根据对其规则，其中最大的为double类型8个字节，故后延查找8的整数倍为8，由此得出从起始位置为8，占用位置为（8-31），共占用31个字节，为8的整数倍，符合对齐规则，得出MyStruct1的sizeof为32.
   ```

   ![image.png](https://tva1.sinaimg.cn/large/e6c9d24egy1h32eqft5ycj20xc05k3z8.jpg)

## 对象的分类

- 生成main.cpp文件

  ```
  feellife@apps-iMac isa指针01 % xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m 

  ```

### instance

- 存储的信息包括
  - isa 指针 8个字节 作用 调用父类方法
  - 其他成员变量
  - isa的地址在对象的最前面 所以也就是对象的地址
- 不存储**实例对象方法**

### class对象

- class的superclass指针

  > 调用实例方法 

  - student 调用init方法时 init属于NSObject 先通过isa找到student的class对象 在通过superclass找到 person的class ==》person的superclass找到 NSObject的class

  ![74AC9D7A-7C45-4F9C-929F-90C8F632AD57](https://tva1.sinaimg.cn/large/e6c9d24egy1h3i4hg50aqj21sk0tegqz.jpg)


- 存储**实例对象方法**

![img](https://upload-images.jianshu.io/upload_images/6545546-81240313e9a503dc.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

- isa指针
- super_class指针

### meta-class

- **存储类对象**


- 元类是一个类对象的类  （也是一个对象，所以也必须有类指针）

- 使用super_class 指针来指向 superclass

- 调用类方法流程

  > 调用类方法时 通过isa找到student的meta-class 通过meta-class里面的superclass找到person的meta-class --》〉


### isa superclass

- **instance的isa指向class  class的isa指向meta-class meta-class的isa指向 root-class的meta-class**


- subclass 子类 Student  Superclass Person  rootclass NSObject 
  - Student继承自Person类

- [x] ​

------

![img](https://upload-images.jianshu.io/upload_images/3044508-18e0ce1fedc91a37.jpeg?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

- subclass查找实例方法流程

  ![1105A5B6-2F5E-4336-A376-C1D900042385](https://tva1.sinaimg.cn/large/e6c9d24egy1h3j5bppdpnj20oi10qae1.jpg)

- subclass查找类方法

  ![6E274132-9F0F-441D-B25B-6312FC2644C5](https://tva1.sinaimg.cn/large/e6c9d24egy1h3j64l749wj20v80u0aer.jpg)

### class和meta-class inside结构

```
struct objc_object {
    Class _Nonnull isa;
};

struct objc_class : objc_object {
    Class superclass;
    cache_t cache;
    class_data_bits_t bits;    // 用户获取类的具体信息
}
```



## KVO

```
[self.person addObserver:self forKeyPath:@"age" options:options context:nil]; 
//context 上下文传递
```

- 添加监听的属性 会使用runtime动态生成派生类-NSKVONotifying_person ，并且让instance的isa指向全新的类，是Person的子类 里面的superlcass指针指向Person  通过foundation底层方法改变值

- 没有监听属性的对像isa 打印依然是Person  object_getClassName 打印

  ```objective-c
  (lldb) p object_getClassName(self.person)
  (const char * _Nonnull) $0 = 0x0000600002063360 "NSKVONotifying_Person"
  //  person2是没有添加观察的类 isa指向的是class对象 按照之前的图
    (lldb) p object_getClassName(self.person2)
  (const char * _Nonnull) $1 = 0x00000001026572de "Person"
  ```

- 打印地址值

  ```objective-c
   NSLog(@"%p --%p",[self.person methodForSelector:@selector(setAge:)],[self.person2 methodForSelector:@selector(setAge:)]);
  (lldb) p (IMP) 0x100381d94
  (IMP) $0 = 0x0000000100381d94 (KVO`-[Person setAge:] at Person.h:13)
  (lldb) p (IMP) 0x1807ab9bc
  (IMP) $1 = 0x00000001807ab9bc (Foundation`_NSSetIntValueAndNotify)
  ```

### NSKVONotifying_person实现

![img](https://upload-images.jianshu.io/upload_images/3333296-36bcadffb5a684bd.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

- 调用Foundation _NSSetIntValueAndNotify方法 实现

  ```objective-c
  [self willChangeValueForKey:@"age"];调用自己的方法
  [super setAge:age]; 调用原类Person的set方法 修改属性值
  [self didChangeValueForKey:@"age"];再回来调用自己的方法
  ```

- Foundation封闭 可以通过重写父类方法也就是Person类添加 willchange 和didchange 方法验证 



### 应用场景

- 看instance是否有set方法

- 直接修改属性不会触发 

  ```
  通过暴露属性去修改不会触发
  {
    @public
    int _age;
  }
  ```

  ​

## KVC

-  person类里定义cat对象 修改cat成员的值

  ```
   //cat对象必须要存在
      [self.person setValue:@49 forKeyPath:@"cat.weight"];
  ```

- KVC会触发KVO监听 不管有没有set方法都会触发

  [取值表]()

  ![img](https://upload-images.jianshu.io/upload_images/4130989-3b4c3c7cc11c1b8c.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)


## Category

- 一个类永远只有一个类对象。不存在分类类对象  多个分类通过runtime动态合并到类信息中(类对象 元类)。存到类对象的方法列表， 最终都是通过instance对象的isa到类对象中寻找，然后调用
- 所有分类中的类方法都会合并到一个元类对象 存储到元类的方法列表


- 属性和成员变量两个概念 属性可以通过点语法访问 成员变量是带_这种

  - clang查看

    ```objective-c
    feellife@apps-iMac ~ % clang -rewrite-objc Person+Eat.m -o category.cpp

    ```

- 添加属性访问

  ```objective-c
  @interface NSObject (test)
  @property (nonatomic,strong) NSString *name;
  @end
  NSString *_name;
  @implementation NSObject (test)
  - (NSString *)name {
  return _name;
  }
  - (void)setName:(NSString *)name{
  _name = name;
  }
  ```

  ​

- 同样的方法会优先调用分类，分类方法是最后添加到方法数组 数组取值通过while-- 最后面参与编译的放在前面 原来的方法列表是最前面  **while（--）顺序调用**

  ​

  - 可以修改编译顺序  Person+Eat在最后面 同一个方法 会最先调用Eat里面的

  ![D624D448-2CDA-4027-9453-077E2307D680](https://tva1.sinaimg.cn/large/e6c9d24egy1h3umcizivdj210q09yq3i.jpg)

```objective-c
struct category_t {
    const char *name;// 类名
    classref_t cls;// 类
    WrappedPtr<method_list_t, PtrauthStrip> instanceMethods; // 实例方法列表
    WrappedPtr<method_list_t, PtrauthStrip> classMethods; // 类方法列表
    struct protocol_list_t *protocols;// 协议列表
    struct property_list_t *instanceProperties;// 属性列表 这个是最后一个成员
  //分类所定义的实例属性，不过我们一般在分类中添加属性都是通过关联对象来实现的
    // Fields below this point are not always present on disk.
    struct property_list_t *_classProperties; //这个可以当作不存在
// 如果是元类,就返回类方法列表;否则返回实例方法列表
    method_list_t *methodsForMeta(bool isMeta) {
        if (isMeta) return classMethods;
        else return instanceMethods;
    }

    property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);
    
    protocol_list_t *protocolsForMeta(bool isMeta) {
        if (isMeta) return nullptr;
        else return protocols;
    }
};
```

### load

- 先调用父类的方法 按编译顺序调用 子类后调用 最后在调用分类（按编译顺序）


- 不用导入头文件就直接被调用 

  ```objective-c
   //源码 +load 方法时 与其他类方法不同 先调用类方法 在调用分类的  通过函数指针指向内存地址值直接拿到方法所以不同 其他的都是通过objc_msgsend 通过isa 拿方法
   while (loadable_classes_used > 0) {
              call_class_loads();
          }

          // 2. Call category +loads ONCE
    more_categories = call_category_loads();
  ```

  ​

- 主动调用**[Class load]**就是 objc_msgsend 就会按照消息发送机制，通过`isa`指针找到类、元类，之后在方法列表中进行查找

###  initialize

- 类第一次接受到消息调用 **[person alloc]**  父类的`+initialize`方法可能会被调用多次 只调用一次 内部会先判断父类有没初始化 在判断子类有没初始化

  ```objective-c
  if ((behavior & LOOKUP_INITIALIZE)  &&  !cls->isInitialized())
  ```

  ​

- 先调用父类 在调用子类  有一个子类就是会调用两次（父类未实现先调用父类 在判断子类有没实现 没实现调用一次）  依此类推 两个子类就会调用三次（发送三条消息）

### Associated

- .m文件声明int _age属性重写set get方法可以实现 缺点 全局属性 多个对象时 取值错误  通过字典包装key 也是全局存在 内存问题

- get set 

  ```objective-c
  const void *NameKey = &NameKey; extern外部可以访问  加上static防止
  objc_setAssociatedObject(self, @selector(name), name, OBJC_ASSOCIATION_COPY_NONATOMIC);
  return  objc_getAssociatedObject(self, _cmd);
  //消除关联对象 
  person.name = @""; person.name = nil;
  相当于 objc_setAssociatedObject(person, @"temp", nil, OBJC_ASSOCIATION_ASSIGN);
  ```

  ​

## block

- 有结构体 isa指针 本质上就是oc对象 里面封装了函数

- clang编译一下 feellife@apps-iMac ~ % clang -rewrite-objc main.m -o block.cpp

  ```objective-c
  struct __block_impl {
    void *isa;
    int Flags;
    int Reserved; 
    void *FuncPtr; //block代码块放在一个函数里面 这个就是指向函数地址的指针
  };
  struct __main_block_impl_0 {
    struct __block_impl impl;
    struct __main_block_desc_0* Desc; //描述信息 block内存大小

    //构造函数 *fp 函数地址
    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {
      impl.isa = &_NSConcreteStackBlock;
      impl.Flags = flags;
      impl.FuncPtr = fp;
      Desc = desc;
    }
  };
  ```

### 变量捕获 capture

- 局部变量  捕获到block struct内部 新增一个成员或指针来存储外面的变量 

  - auto int a =10 离开作用域就销毁  **值传递**  离开block再去修改值 block里面的新增的成员值不会变化

  - static int b =20 **指针传递** block内部的值会跟着改变

    ```objective-c
      struct __block_impl impl;
      struct __main_block_desc_0* Desc;
      int c;//auto修饰的变量
      int *d; //static指针修饰的变量
    ```

  - self 也是局部变量 当被传递的时候 作为参数

- 全局变量  已经存到内存了 不需要额外再存到block结构体

  - 不需要捕获 直接访问变量
  - 函数外面定义的变量称作全局变量 

### block类型

- 所有block都继承自**NSBlock**  最终类型以运行时为准

- **__NSGlobalBlock__**

  - 没有访问auto变量  static 全局不属于auto 所以都是全局 block  放在数据段

  - 调用copy 什么都不会发生 依然在global

    ```objective-c
     void(^block1)(void) = ^{
            NSLog(@"HT_Block");
     };
     NSLog(@"%@",block1); // 打印： <__NSGlobalBlock__: 0x102239040>
    ```

- **NSStackBlock**   和全局block对立 完全相反 

  - ​


  - 存储在栈区 作用域消失后数据可能会错乱 内存被回收了 随时可能被销毁
  - 访问了auto变量 
  - 调用copy 从栈拷贝到堆区 产生堆内存的block


  ```objective-c
  //block没有任何参数返回所以不会自动copy 依然是stackblock
  NSLog(@"type5=  %@ %@",[^{NSLog(@"1111=%d",c);}  class],[[^{NSLog(@"1111=%d",c);} class] superclass]);
  ```

  ​

- **__NSMallocBlock__** 存储在堆区  

  - ARC下我们使用block的时候，系统很多情况下都会自动帮我们复制一份栈block到堆区

    - blcok作为函数参数返回

      ```objective-c
      //这个是stack block 但是blcok作为函数参数返回 ARC下系统自动复制了，所以看不到copy操作 变成堆区Block
       int aaa =10; 
          void(^cblock)(void)= ^(){       
           NSLog(@"this is cblock %d",aaa);     
        };
       NSLog(@"type3=  %@ %@",[cblock class],[[cblock class] superclass]);

      ```

    - __strong

    - GCD会自动copy


  - stack copy操作

  - 堆区 copy操作 只会引用计数增加

    ```objective-c
    auto int c = 30;
    [[^{NSLog(@"1111=%d",c);} copy] class] //不加copy就是stackblock 加了就是malloc

    ```


### 修改变量

- _ _block

  ```objective-c
  // 结构体的内存地址：0x000000010073c240，也就是结构体首成员isa的内存地址
  struct __Block_byref_age_0 {
    void *__isa; // 0x000000010073c240
   struct __Block_byref_age_0 *__forwarding; // 0x000000010073c240 + 8 = 0x000000010073c248
   int __flags; // 0x000000010073c248 + 8 = 0x000000010073c250
   int __size; // 0x000000010073c250 + 4 = 0x000000010073c254
   int age; // 0x000000010073c254 + 4 = 0x000000010073c258
  };
  ```

  - 不能修饰static变量

    ​

- 变成全局也可以修改 传递的是指针地址

## 数据结构

### 链表

## 常用算法

### 时间复杂度

![img](https://tva1.sinaimg.cn/large/e6c9d24egy1h3b3tzai9tj21gl0u0gta.jpg)

### Binary Search（BS 二分查找）

- 前提 必须在有序数据中查找
- 方法：每次将范围[left right]分割成【left mid】[mid right]


- ![img](https://tva1.sinaimg.cn/large/e6c9d24egy1h38omdw8j5j217005wweq.jpg)

  ​










